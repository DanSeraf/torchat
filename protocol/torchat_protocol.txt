Abstract

   The TORChat protocol is an
   application profile of the JSON language that
   enables the near-real-time exchange of structured yet extensible data
   between any two or more network entities on the TOR network.
   This document defines
   TORChat's core protocol methods: setup and teardown of JSON streams,
   channel encryption, authentication, error handling, and communication
   primitives for messaging, network availability ("presence"), and
   request-response interactions. 

1.  Introduction

1.1.  Overview

   The TORChat protocol is an 
   application profile of the JSON language that 
   enables the near-real-time exchange of structured yet extensible data
   between any two or more network entities on the TOR network.
   This document defines
   TMX's core protocol methods: setup and teardown of JSON streams,
   channel encryption, authentication, error handling, and communication
   primitives for messaging, network availability ("presence"), and
   request-response interactions.

1.3.  Functional Summary

   This non-normative section provides a developer-friendly, functional
   summary of TMX; refer to the sections that follow for a normative
   definition of TMX.

   The purpose of TMX is to enable the exchange of relatively small
   pieces of structured data (called "JSON message unit", JMU or jmu) over a network
   between any two (or more) entities.  JSON is typically implemented
   using a distributed server-server architecture, wherein a node on the
   network is the server itself identified by its unique .onion domain.	
   The process whereby a
   node connects to the network and exchange messages with one other node,
   in the form of jmu, and ends the connection is:

   1.  Open a Transmission Control Protocol [TCP] connection with a
	   node on the network.

   2.  Send an opening jmu over TCP (Section 4.2)

   3.  Exchange an unbounded number of jmu's with the other node
       on the network (Section 8)

   5.  Send a closing jmu (Section 4.4)

   6.  Close the TCP connection

   The process whereby a node connects to the network and sends a binary
   stream to another node and ends the connection is:

   1.  Open a Transmission Control Protocol [TCP] connection with a
	   node on the network, if not already opened.

   2.  Send an opening jmu over TCP (Section 4.2)

   3.  Exchange an unbounded number of jmu's with the other node
       on the network (containing the binary data, serialized)

   5.  Send a closing jmu (Section 4.4)

   6.  Close the TCP connection

   This document specifies how nodes connect to the network and specifies
   the basic semantics of jmu.



1.4.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in RFC
   2119 [KEYWORDS].

   Certain security-related terms are to be understood in the sense
   defined in [SEC-TERMS]; such terms include, but are not limited to,
   "assurance", "attack", "authentication", "authorization",
   "certificate", "certification authority", "certification path",
   "confidentiality", "credential", "downgrade", "encryption", "hash
   value", "identity", "integrity", "signature", "self-signed
   certificate", "sign", "spoof", "tamper", "trust", "trust anchor",
   "validate", and "verify".

   Other security-related terms are to be understood in the sense
   defined in the referenced specifications (for example, "denial of
   service" as described in [DOS] or "end entity certificate" as
   described in [PKIX]).

   The term node defines a server that one single user connects to 
   with an unspecified local computer client in order to enter the
   TOR network and   exchange messages with other nodes.
   The term "TID" refers to a .onion domain address of the form
   <xxx.onion>.


   The term "JMU" (also "jmu") is defined under Section 4.1.
   There are two kinds of JSON message units: message, binary stream.

   The term "originating entity" refers to the entity that first
   generates a stanza that is sent over an TMX network (e.g., a
   connected client, an add-on service, or a server).  The term
   "generated stanza" refers to the stanza so generated.

   The term "input stream" designates a stream of jmu over which a node
   receives data from a connected node, and the term
   "output stream" designates a stream of jmu over which a server sends
   data to a connected node.  The following terms
   designate some of the actions that a server can perform when
   processing data received over an input stream:

      route:  pass the data to a remote server for direct processing by
         the remote server or eventual delivery to a client associated
         with the remote server

      deliver:  pass the data to the user of the node.

      ignore:  discard the data without acting upon it or returning an
         error to the sender

   When the term "ignore" is used with regard to client processing of
   data it receives, the phrase "without acting upon it" explicitly
   includes not presenting the data to a human user.

   In examples, lines have been wrapped for improved readability,
   "[...]" means elision, and the following prepended strings are used
   (these prepended strings are not to be sent over the wire):

   o  C: = a client

   o  E: = any TMX entity

   o  I: = an initiating entity

   o  P: = a peer server

   o  R: = a receiving entity

   o  S: = a server

   o  S1: = server1

   o  S2: = server2

   Readers need to be aware that the examples are not exhaustive and
   that, in examples for some protocol flows, the alternate steps shown
   would not necessarily be triggered by the exact data sent in the
   previous step; in all cases the protocol definitions specified in
   this document or in normatively referenced documents rule over any
   examples provided here.  All examples are fictional and the
   information exchanged (e.g., usernames and passwords) does not
   represent any existing users or servers.

2.  Architecture

   TMX provides a technology for the asynchronous, end-to-end exchange
   of structured data by means of direct, persistent TMX streams among a
   distributed network of globally addressable, presence-aware
   servers.  Because this architectural style involves ubiquitous
   knowledge of network availability and a conceptually unlimited number
   of concurrent information transactions in the context of a given
   client-to-server or server-to-server session, we label it
   "Availability for Concurrent Transactions" (ACT).
   The salient features of this ACTive architectural style are as follows.

2.1.  Global Addresses

   As with email,  TMX uses globally unique addresses (based on the
   .onion domain system) in order to route and deliver messages over the
   network.  All TMX entities are addressable on the network, most
   particularly nodes but also various additional services
   that can be accessed by users from their nodes.

2.2.  Presence

   TMX does not includes the ability for an entity to advertise its network
   availability or "presence" to other entities.

2.3.  Persistent Streams

   Availability for communication is also built into each point-to-point
   "hop" through the use of persistent JSON streams over long-lived TCP
   connections.  These "always-on" node-to-node
   streams enable each party to push data to the other party at any time
   for immediate routing or delivery.

2.4.  Structured Data

   The basic protocol data unit in JSON is not a TCP stream (which
   simply provides the transport for point-to-point communication) but
   a jmu, which is essentially a small piece of JSON that is sent
   over a stream.  The root element of a jmu includes routing
   attributes (such as "from" and "to" addresses), and the child
   elements of the stanza contain a payload for delivery to the intended
   recipient.

2.5.  Distributed Network of Clients and Servers

   In practice, TMX consists of a network of clients and servers that
   inter-communicate (however, communication between any two given
   deployed servers is strictly discretionary and a matter of domain whitelists
   implemented independently). 
   Thus for example, the user at the domain juliet.onion
   associated with the server running the .onion domain over the TOR network
    might be able to exchange messages and files, and other structured data with the user
   romeo.onion associated with the server running the .onion domain over the TOR network.
   As a result, end-to-end communication in TMX is logically peer-to-
   peer but physically server-to-server, as
   illustrated in the following diagram.

     juliet.onion <-----TOR Network-----> romeo.onion

             Figure 1: Distributed Server-Server Architecture

   The following paragraphs describe the responsibilities servers on the network.

   A node is an entity that establishes a TCP stream with another node,
   then completes resource binding (Section 7) in order to 
   enable delivery of jmu's  between the servers connected to the network.
   This document do not describe the use and implementation of a client that 
   may interact with the user in order to ease the process of creating and sending
   jmu to other nodes on the network.

   A node is an entity whose primary responsibilities are to:

   o  Manage TCP streams (Section 4) with connected nodes and deliver
      jmu (Section 8) to those nodes over the negotiated
      streams.

   o  Subject to local service policies on server-to-server
      communication, manage TCP streams (Section 4) with remote servers
      and route jmu's (Section 8) to those servers over the
      negotiated streams.

   Depending on the application, the secondary responsibilities of an
   TMX server can include:

   o  Storing data that is used by users (e.g., contact lists for
      users of TMX-based instant messaging); 
      In this case, the relevant jmu is handled directly by the server itself 
      on behalf of the client and is not routed to a remote node.

   o  Hosting add-on services that also use TMX as the basis for
      communication.

3.  TCP Binding

3.1.  Scope

   As TMX is defined in this specification, an initiating entity
   (client or server) MUST open a Transmission Control Protocol [TCP]
   connection to the receiving entity (server) before it negotiates jmu 
   streams with the receiving entity.  The parties then maintain that
   TCP connection for as long as the streams are in use.  The rules
   specified in the following sections apply to the TCP binding.

3.2.  Resolution of Fully Qualified Domain Names

   Because jmu's are sent over TCP, the initiating entity needs to
   determine the .onion address (and port) of the receiving entity
   before it can attempt to open a TCP stream.  Typically this is done
   by resolving the .onion domain using the capabilities of the TOR daemon
   running on the host machine.



3.4.  Reliability

   The use of long-lived TCP connections in TMX implies that the
   sending of jmu over a TCP stream can be unreliable, since the
   parties to a long-lived TCP connection might not discover a
   connectivity disruption in a timely manner.  At the TMX application
   layer, long connectivity disruptions can result in undelivered jmu's.

4. JSON message units

4.1.  JMU fundamental

   JMU is at the basis of rapid, asynchronous exchange of payloads over 
   the TMX protocol. Terms are defined as follows.

   Definition of JSON Message Unit:
	  A JSON Message Unit is a JSON structured stream sent between any
 	  two entities over the TOR network.
	  During the life of the TCP stream the entity that initiated it can
      send an unbounded number of jmu's over the stream.
	  The initial jmu is negotiated fgrom the initiating entity to
      the receiving entity and can be seen as the beginning of the session.
	  The opening jmu enables bidirectional communication between the 
	  initiating and receiving entity.
   
   There are two kinds of jmu: message and file transfer.
   These two types provide the same communication primitive:
   a "push" mechanism.

   Consider the example of a node's connection to another node server.  
   The node initiates the exchange by sending an opening jmu header to the
   other node, preferably preceded by a jmu declaration specifying the jmu
   version.  Subject to local policies and service provisioning,
   the second then replies with an "ACK" jmu back to the first node,
   Once the    (Section 7), the client can send an unbounded number of jmu
   over the stream.  When one node desires to close the stream, it
   simply sends a closing jmu to the other node as further
   described under Section 4.4.
   A simple graphical explanation follows:

   +--------------------+--------------------+
   | INITIAL STREAM     |  RESPONSE STREAM   |
   +--------------------+--------------------+
   | {'open': ...,      |                    |
   |   'from': ...,     |                    |
   |   'version': ...,  |                    |
   |    ...             |                    |
   | }                  |                    |
   |--------------------|--------------------|
   |                    | {'ack': ...        |
   |                    |  ...               |
   |                    | }                  |
   |--------------------|--------------------|
   | {'message':'foo',  |                    |
   |   'from': ...,     |                    |
   |   ...              |                    |
   | }                  |                    |
   |--------------------|--------------------|
   | {'message':'bar',  |                    |
   |   'from': ...,     |                    |
   |   ...              |                    |
   | }                  |                    |
   |--------------------|--------------------|
   | [ ... ]            |                    |
   |--------------------|--------------------|
   |                    | [ ... ]            |
   |--------------------|--------------------|
   | {'close': ...,     |                    |
   |   'from': ...,     |                    |
   |    ...             |                    |
   | }                  |                    |
   |--------------------|--------------------|
   |                    | {'ack': ...        |
   |                    |  ...               |
   |                    | }                  |
   +--------------------+--------------------+

   The remainder of this section defines the following aspects of TMX
   streams (along with related topics):

   o  How to open a stream (Section 4.2)

   o  The stream negotiation process (Section 4.3)

   o  How to close a stream (Section 4.4)

   o  The directionality of jmu streams (Section 4.5)

   o  How to handle peers that are silent (Section 4.6)

   o  The jmu attributes of a stream (Section 4.7)

   o  The jmu namespaces of a stream (Section 4.8)

   o  Error handling related to jmu streams (Section 4.9)

4.2.  Opening a Stream

   After connecting to the appropriate .onion domain and port of the
   receiving entity, the initiating entity opens a stream by sending a
   jmu header (the "initial jmu") to the receiving entity.

   I: {
       'TMX version':1'
       'open':'message''
       'from':'juliet.onion' 
      }

   The receiving entity then replies by sending a stream header of its
   own (the "response stream header") to the initiating entity.

   R: {
      'version':1,
	  'ack':True,
	  'from':'romeo.onion'
      }

   The entities can then proceed sending other jmu's.
   In the above example, the first jmu specify the type message
   for the initiated communication.

   The initiating entity MUST NOT attempt to send jmu's
   (Section 8) to other entities until stream
   negotiation has been completed.  Even if the initiating entity does
   attempt to do so, the receiving entity MUST NOT accept such jmu's
   and MUST close the stream with a 'error':'not-authorized' jmu error


4.4.  Closing a Stream

   An TCP stream from one entity to another can be closed at any time,
   either because a specific stream error (Section 4.9) has occurred or
   in the absence of an error (e.g., when a node simply ends its
   session).

   A stream is closed by sending a closing jmu.

   E: {'close':True,
	   'from':'romeo.onion'
      }
	
   1.  Wait for the other party to also close its outbound stream before
       terminating the underlying TCP connection(s); this gives the
       other party an opportunity to finish transmitting any outbound
       data to the closing entity before the termination of the TCP
       connection(s).

   2.  Refrain from sending any further data over its outbound stream to
       the other entity, but continue to process data received from the
       other entity (and, if necessary, process such data).

   3.  Consider the stream to be void if the other party does not send
       its closing stream tag within a reasonable amount of time (where
       the definition of "reasonable" is a matter of implementation or
       deployment).

   4.  After receiving a reciprocal closing jmu from the other
       party or waiting a reasonable amount of time with no response,
       terminate the underlying TCP connection.

4.5.  Directionality

   An jmu of message type is always unidirectional, by which is meant that 
   it doesn't need an ack.

4.6.  Handling of Silent Peers

   When an entity that is a party to a stream has not received any TMX
   traffic from its stream peer for some period of time, the peer might
   appear to be silent.  There are several reasons why this might
   happen:

   1.  The underlying TCP connection is dead.

   	   2.  One of the jmu's that has been sent is broken despite the fact that
       the underlying TCP connection is alive.

   3.  The peer is idle and simply has not sent any TMX traffic over
       its TCP stream to the entity.

   These three conditions are best handled separately, as described in
   the following sections.

4.6.1.  Dead Connection

   If the underlying TCP connection is dead, stream-level checks (e.g.,
   [XEP-0199] and [XEP-0198]) are ineffective.  Therefore, it is
   unnecessary to close the stream with or without an error, and it is
   appropriate instead to simply terminate the TCP connection.

   One common method for checking the TCP connection is to send a space
   a ping jmu.

4.6.2.  Broken Stream

   Even if the underlying TCP connection is alive, the peer might never
   respond to TMX traffic that the entity sends, whether normal jmu's
   or specialized stream-checking traffic such as the application-level
   pings. In this case, it is appropriate for the entity to close a broken stream 
   with an error jmu containing the 'connection-timeout' error.

4.6.3.  Idle Peer

   Even if the underlying TCP connection is alive and the stream is not
   broken, the peer might have sent no stanzas for a certain period of
   time.  In this case, the peer itself MAY close the stream (as
   described under Section 4.4) rather than leaving an unused stream
   open.  If the idle peer does not close the stream, the other party
   MAY either close the stream using the handshake described under
   Section 4.4 or close the stream with a stream error (e.g., 'resource-
   constraint' if the entity has reached a limit on
   the number of open TCP connections or 'connection-timeout'
   connection has exceeded a local timeout  policy). 
    However, consistent with the order of layers (specified
   under Section 13.3), the other party is advised to verify that the
   underlying TCP connection is alive and the stream is unbroken (as
   described above) before concluding that the peer is idle.

4.7.  JMU Attributes

   The attributes of a jmu are defined in the following sections.

4.7.1. from

   The 'from' attribute specifies the .onion domain associated with the
   identity of the entity opening the stream.
   It corresponds with the identity of the user sending the message.

4.7.2. features
   
   The 'features' attribute specifies the features requested/available on a node.
   See Section 4.10.

4.7.5. version

   The inclusion of the version attribute set to a value of at least
   "1.0" signals support for the stream-related protocols defined in
   this specification.

   The version of TMX specified in this specification is "1.0".
   The numbering scheme for TMX versions is "<major>.<minor>".  The
   major and minor numbers MUST be treated as separate integers and each
   number MAY be incremented higher than a single digit.  Thus, "TMX
   2.4" would be a lower version than "TMX 2.13", which in turn would
   be lower than "TMX 12.3".  Leading zeros (e.g., "TMX 6.01") MUST be
   ignored by recipients and MUST NOT be sent.

   1.  The initiating entity MUST set the value of the 'version'
       attribute in the initial stream header to the highest version
       number it supports (e.g., if the highest version number it
       supports is that defined in this specification, it MUST set the
       value to "1.0").

   2.  The receiving entity MUST set the value of the 'version'
       attribute in the response stream header to either the value
       supplied by the initiating entity or the highest version number
       supported by the receiving entity, whichever is lower.  The
       receiving entity MUST perform a numeric comparison on the major
       and minor version numbers, not a string match on
       "<major>.<minor>".

   3.  If the version number included in the response stream header is
       at least one major version lower than the version number included
       in the initial stream header and newer version entities cannot
       interoperate with older version entities as described, the
       initiating entity SHOULD close the stream with an <unsupported-
       version/> stream error (Section 4.9.3.25).

   4.  If either entity receives a stream header with no 'version'
       attribute, the entity MUST consider the version supported by the
       other entity to be "0.9" and SHOULD NOT include a 'version'
       attribute in the response stream header.


4.7.6.  Summary of Stream Attributes

   The following table summarizes the attributes of the jmu
   element.

   +-----------+--------------------------+-------------------------+
   |           | initiating to receiving  | receiving to initiating |
   +-----------+--------------------------+-------------------------+
   | to        | JID of receiver          | JID of initiator        |
   | from      | JID of initiator         | JID of receiver         |
   | version   | TMX 1.0+ supported       | TMX 1.0+ supported      |
   | features  | request features         | list of features        |
   +-----------+--------------------------+-------------------------+

4.9.  Stream Errors

   The root stream element MAY contain an "error' attribute that is
   qualified by the stream namespace.  The error child SHALL be sent by
   a compliant entity if it perceives that a stream-level error has
   occurred.

4.9.1.  Rules

   The following rules apply to stream-level errors.

4.9.1.1.  Stream Errors Are Unrecoverable

   Stream-level errors are unrecoverable.  Therefore, if an error occurs
   at the level of the stream, the entity that detects the error MUST
   send an <error/> element with an appropriate child element specifying
   the error condition and then immediately close the stream.

4.9.1.2   Possible types of errors
+-------------------------------------+
|        Possible errors              |
+-------------------------------------+
| bad-format						  |
| conflict                            |
| connection-timeout                  |
| host-unknown                        |
| Improper Addressing                 |
| internal-server-error               |
| invalid-from                        |
| invalid-JSON                        |
| not-authorized                      |
| policy-violation                    |
| reset                               |
| resource-constraint                 |
| system-shutdown                     |
| unsupported-encoding                |
| unsupported-message-type            |
| unsupported-version                 |
| unsupported-feature                 |
+----------+---------------------------

4.10     Features 
   
   A jmu may contain a 'features' attribute.
   "features" supported by a node acts as an extension to the protocol.
   A feature is just a simple key-value inside the JSON stream of the jmu
   and is interpreted by the node implementing the feature independently.

4.10.1  Request a feature

   A node requesting a feature to another node in order to initiate
   an exchange sends a jmu containing the attribute 'feature' with the
   feature requested as a value.
   
   I: {
       'TMX version':1',
       'features':'auth',
       'from':'juliet.onion' 
      }

   The receiving entity then replies by sending a jmu of its
   own to the initiating node with the supported feature.

   R: {
      'version':1,
	  'features':'auth',
	  'from':'romeo.onion'
      }
	
   Or the receiving entity then replies by sending a jmu of its
   own to the initiating node with the unsupported feature.

   R: {
      'version':1,
	  'features':'',
	  'from':'romeo.onion'
      }

   Or a node may request the list of features of another node.

   I: {
       'TMX version':1',
       'features':'',
       'from':'juliet.onion' 
      }

   The receiving entity then replies by sending a jmu of its
   own to the initiating node with the supported feature.

   R: {
      'version':1,
	  'features':'auth,presence',
	  'from':'romeo.onion'
      }

4.10.2 Summary of possible key-value combinations

   +-----------+--------------------------+---------------------------------- +
   |           | initiating to receiving  | receiving to initiating           |
   +-----------+--------------------------+-----------------------------------+
   | request   | name of the feature      | * empty value if not supported    |
   | specific  | as a value in the json   | * name of the feature as value if |
   | feature   |                          |  supported                        |
   +-----------+--------------------------+-----------------------------------+
   | request   | empty string as value    | reply with comma divided          |
   | list of   | of requesty key in json  | features inside as value of key   |
   | features  | request features         |                                   |
   +-----------+--------------------------+-----------------------------------+
