Abstract

   The TORChat protocol is an
   application profile of the JSON language that
   enables the near-real-time exchange of structured yet extensible data
   between any two or more network entities on the TOR network.
   This document defines
   TORChat's core protocol methods: setup and teardown of JSON streams,
   channel encryption, authentication, error handling, and communication
   primitives for messaging, network availability ("presence"), and
   request-response interactions. 


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   8
     1.1.   Overview . . . . . . . . . . . . . . . . . . . . . . . .   8
     1.2.   History  . . . . . . . . . . . . . . . . . . . . . . . .   8
     1.3.   Functional Summary . . . . . . . . . . . . . . . . . . .   9
     1.4.   Terminology  . . . . . . . . . . . . . . . . . . . . . .  11
   2.  Architecture  . . . . . . . . . . . . . . . . . . . . . . . .  13
     2.1.   Global Addresses . . . . . . . . . . . . . . . . . . . .  13
     2.2.   Presence . . . . . . . . . . . . . . . . . . . . . . . .  14
     2.3.   Persistent Streams . . . . . . . . . . . . . . . . . . .  14
     2.4.   Structured Data  . . . . . . . . . . . . . . . . . . . .  14
     2.5.   Distributed Network of Clients and Servers . . . . . . .  14
   3.  TCP Binding . . . . . . . . . . . . . . . . . . . . . . . . .  16
     3.1.   Scope  . . . . . . . . . . . . . . . . . . . . . . . . .  16
     3.2.   Resolution of Fully Qualified Domain Names . . . . . . .  17
       3.2.1.   Preferred Process: SRV Lookup  . . . . . . . . . . .  17
       3.2.2.   Fallback Processes . . . . . . . . . . . . . . . . .  18
       3.2.3.   When Not to Use SRV  . . . . . . . . . . . . . . . .  18
       3.2.4.   Use of SRV Records with Add-On Services  . . . . . .  19
     3.3.   Reconnection . . . . . . . . . . . . . . . . . . . . . .  19
     3.4.   Reliability  . . . . . . . . . . . . . . . . . . . . . .  20
   4.  XML Streams . . . . . . . . . . . . . . . . . . . . . . . . .  20
     4.1.   Stream Fundamentals  . . . . . . . . . . . . . . . . . .  20
     4.2.   Opening a Stream . . . . . . . . . . . . . . . . . . . .  23
     4.3.   Stream Negotiation . . . . . . . . . . . . . . . . . . .  24
       4.3.1.   Basic Concepts . . . . . . . . . . . . . . . . . . .  24
       4.3.2.   Stream Features Format . . . . . . . . . . . . . . .  25
       4.3.3.   Restarts . . . . . . . . . . . . . . . . . . . . . .  27
       4.3.4.   Resending Features . . . . . . . . . . . . . . . . .  27
       4.3.5.   Completion of Stream Negotiation . . . . . . . . . .  27
       4.3.6.   Determination of Addresses . . . . . . . . . . . . .  28
       4.3.7.   Flow Chart . . . . . . . . . . . . . . . . . . . . .  29
     4.4.   Closing a Stream . . . . . . . . . . . . . . . . . . . .  31
     4.5.   Directionality . . . . . . . . . . . . . . . . . . . . .  32
     4.6.   Handling of Silent Peers . . . . . . . . . . . . . . . .  33
       4.6.1.   Dead Connection  . . . . . . . . . . . . . . . . . .  34
       4.6.2.   Broken Stream  . . . . . . . . . . . . . . . . . . .  34
       4.6.3.   Idle Peer  . . . . . . . . . . . . . . . . . . . . .  34
       4.6.4.   Use of Checking Methods  . . . . . . . . . . . . . .  35
     4.7.   Stream Attributes  . . . . . . . . . . . . . . . . . . .  35
       4.7.1.   from . . . . . . . . . . . . . . . . . . . . . . . .  35
       4.7.2.   to . . . . . . . . . . . . . . . . . . . . . . . . .  37
       4.7.3.   id . . . . . . . . . . . . . . . . . . . . . . . . .  38
       4.7.4.   xml:lang . . . . . . . . . . . . . . . . . . . . . .  39
       4.7.5.   version  . . . . . . . . . . . . . . . . . . . . . .  41
       4.7.6.   Summary of Stream Attributes . . . . . . . . . . . .  43
     4.8.   XML Namespaces . . . . . . . . . . . . . . . . . . . . .  43
       4.8.1.   Stream Namespace . . . . . . . . . . . . . . . . . .  43
       4.8.2.   Content Namespace  . . . . . . . . . . . . . . . . .  43
       4.8.3.   XMPP Content Namespaces  . . . . . . . . . . . . . .  44
       4.8.4.   Other Namespaces . . . . . . . . . . . . . . . . . .  46
       4.8.5.   Namespace Declarations and Prefixes  . . . . . . . .  47
     4.9.   Stream Errors  . . . . . . . . . . . . . . . . . . . . .  48
       4.9.1.   Rules  . . . . . . . . . . . . . . . . . . . . . . .  48
         4.9.1.1.  Stream Errors Are Unrecoverable . . . . . . . . .  48
         4.9.1.2.  Stream Errors Can Occur During Setup  . . . . . .  49
         4.9.1.3.  Stream Errors When the Host Is Unspecified or
                   Unknown . . . . . . . . . . . . . . . . . . . . .  50
         4.9.1.4.  Where Stream Errors Are Sent  . . . . . . . . . .  50
       4.9.2.   Syntax . . . . . . . . . . . . . . . . . . . . . . .  51
       4.9.3.   Defined Stream Error Conditions  . . . . . . . . . .  52
         4.9.3.1.  bad-format  . . . . . . . . . . . . . . . . . . .  52
         4.9.3.2.  bad-namespace-prefix  . . . . . . . . . . . . . .  52
         4.9.3.3.  conflict  . . . . . . . . . . . . . . . . . . . .  53
         4.9.3.4.  connection-timeout  . . . . . . . . . . . . . . .  54
         4.9.3.5.  host-gone . . . . . . . . . . . . . . . . . . . .  54
         4.9.3.6.  host-unknown  . . . . . . . . . . . . . . . . . .  55
         4.9.3.7.  improper-addressing . . . . . . . . . . . . . . .  56
         4.9.3.8.  internal-server-error . . . . . . . . . . . . . .  56
         4.9.3.9.  invalid-from  . . . . . . . . . . . . . . . . . .  56
         4.9.3.10. invalid-namespace . . . . . . . . . . . . . . . .  57
         4.9.3.11. invalid-xml . . . . . . . . . . . . . . . . . . .  57
         4.9.3.12. not-authorized  . . . . . . . . . . . . . . . . .  58
         4.9.3.13. not-well-formed . . . . . . . . . . . . . . . . .  59
         4.9.3.14. policy-violation  . . . . . . . . . . . . . . . .  59
         4.9.3.15. remote-connection-failed  . . . . . . . . . . . .  60
         4.9.3.16. reset . . . . . . . . . . . . . . . . . . . . . .  60
         4.9.3.17. resource-constraint . . . . . . . . . . . . . . .  61
         4.9.3.18. restricted-xml  . . . . . . . . . . . . . . . . .  61
         4.9.3.19. see-other-host  . . . . . . . . . . . . . . . . .  62
         4.9.3.20. system-shutdown . . . . . . . . . . . . . . . . .  64
         4.9.3.21. undefined-condition . . . . . . . . . . . . . . .  64
         4.9.3.22. unsupported-encoding  . . . . . . . . . . . . . .  64
         4.9.3.23. unsupported-feature . . . . . . . . . . . . . . .  65
         4.9.3.24. unsupported-stanza-type . . . . . . . . . . . . .  65
         4.9.3.25. unsupported-version . . . . . . . . . . . . . . .  66
       4.9.4.   Application-Specific Conditions  . . . . . . . . . .  67
     4.10.  Simplified Stream Examples . . . . . . . . . . . . . . .  68
   5.  STARTTLS Negotiation  . . . . . . . . . . . . . . . . . . . .  69
     5.1.   Fundamentals . . . . . . . . . . . . . . . . . . . . . .  69
     5.2.   Support  . . . . . . . . . . . . . . . . . . . . . . . .  70
     5.3.   Stream Negotiation Rules . . . . . . . . . . . . . . . .  70
       5.3.1.   Mandatory-to-Negotiate . . . . . . . . . . . . . . .  70
       5.3.2.   Restart  . . . . . . . . . . . . . . . . . . . . . .  70
       5.3.3.   Data Formatting  . . . . . . . . . . . . . . . . . .  70
       5.3.4.   Order of TLS and SASL Negotiations . . . . . . . . .  71
       5.3.5.   TLS Renegotiation  . . . . . . . . . . . . . . . . .  71
       5.3.6.   TLS Extensions . . . . . . . . . . . . . . . . . . .  72
     5.4.   Process  . . . . . . . . . . . . . . . . . . . . . . . .  72
       5.4.1.   Exchange of Stream Headers and Stream Features . . .  72
       5.4.2.   Initiation of STARTTLS Negotiation . . . . . . . . .  73
         5.4.2.1.  STARTTLS Command  . . . . . . . . . . . . . . . .  73
         5.4.2.2.  Failure Case  . . . . . . . . . . . . . . . . . .  73
         5.4.2.3.  Proceed Case  . . . . . . . . . . . . . . . . . .  74
       5.4.3.   TLS Negotiation  . . . . . . . . . . . . . . . . . .  74
         5.4.3.1.  Rules . . . . . . . . . . . . . . . . . . . . . .  74
         5.4.3.2.  TLS Failure . . . . . . . . . . . . . . . . . . .  75
         5.4.3.3.  TLS Success . . . . . . . . . . . . . . . . . . .  76
   6.  SASL Negotiation  . . . . . . . . . . . . . . . . . . . . . .  77
     6.1.   Fundamentals . . . . . . . . . . . . . . . . . . . . . .  77
     6.2.   Support  . . . . . . . . . . . . . . . . . . . . . . . .  77
     6.3.   Stream Negotiation Rules . . . . . . . . . . . . . . . .  77
       6.3.1.   Mandatory-to-Negotiate . . . . . . . . . . . . . . .  77
       6.3.2.   Restart  . . . . . . . . . . . . . . . . . . . . . .  78
       6.3.3.   Mechanism Preferences  . . . . . . . . . . . . . . .  78
       6.3.4.   Mechanism Offers . . . . . . . . . . . . . . . . . .  78
       6.3.5.   Data Formatting  . . . . . . . . . . . . . . . . . .  79
       6.3.6.   Security Layers  . . . . . . . . . . . . . . . . . .  80
       6.3.7.   Simple User Name . . . . . . . . . . . . . . . . . .  80
       6.3.8.   Authorization Identity . . . . . . . . . . . . . . .  80
       6.3.9.   Realms . . . . . . . . . . . . . . . . . . . . . . .  81
       6.3.10.  Round Trips  . . . . . . . . . . . . . . . . . . . .  81
     6.4.   Process  . . . . . . . . . . . . . . . . . . . . . . . .  82
       6.4.1.   Exchange of Stream Headers and Stream Features . . .  82
       6.4.2.   Initiation . . . . . . . . . . . . . . . . . . . . .  83
       6.4.3.   Challenge-Response Sequence  . . . . . . . . . . . .  84
       6.4.4.   Abort  . . . . . . . . . . . . . . . . . . . . . . .  84
       6.4.5.   SASL Failure . . . . . . . . . . . . . . . . . . . .  85
       6.4.6.   SASL Success . . . . . . . . . . . . . . . . . . . .  86
     6.5.   SASL Errors  . . . . . . . . . . . . . . . . . . . . . .  87
       6.5.1.   aborted  . . . . . . . . . . . . . . . . . . . . . .  88
       6.5.2.   account-disabled . . . . . . . . . . . . . . . . . .  88
       6.5.3.   credentials-expired  . . . . . . . . . . . . . . . .  88
       6.5.4.   encryption-required  . . . . . . . . . . . . . . . .  89
       6.5.5.   incorrect-encoding . . . . . . . . . . . . . . . . .  89
       6.5.6.   invalid-authzid  . . . . . . . . . . . . . . . . . .  89
       6.5.7.   invalid-mechanism  . . . . . . . . . . . . . . . . .  90
       6.5.8.   malformed-request  . . . . . . . . . . . . . . . . .  90
       6.5.9.   mechanism-too-weak . . . . . . . . . . . . . . . . .  90
       6.5.10.  not-authorized . . . . . . . . . . . . . . . . . . .  91
       6.5.11.  temporary-auth-failure . . . . . . . . . . . . . . .  91
     6.6.   SASL Definition  . . . . . . . . . . . . . . . . . . . .  91
   7.  Resource Binding  . . . . . . . . . . . . . . . . . . . . . .  92
     7.1.   Fundamentals . . . . . . . . . . . . . . . . . . . . . .  92
     7.2.   Support  . . . . . . . . . . . . . . . . . . . . . . . .  93
     7.3.   Stream Negotiation Rules . . . . . . . . . . . . . . . .  93
       7.3.1.   Mandatory-to-Negotiate . . . . . . . . . . . . . . .  93
       7.3.2.   Restart  . . . . . . . . . . . . . . . . . . . . . .  93
     7.4.   Advertising Support  . . . . . . . . . . . . . . . . . .  93
     7.5.   Generation of Resource Identifiers . . . . . . . . . . .  94
     7.6.   Server-Generated Resource Identifier . . . . . . . . . .  94
       7.6.1.   Success Case . . . . . . . . . . . . . . . . . . . .  94
       7.6.2.   Error Cases  . . . . . . . . . . . . . . . . . . . .  95
         7.6.2.1.  Resource Constraint . . . . . . . . . . . . . . .  95
         7.6.2.2.  Not Allowed . . . . . . . . . . . . . . . . . . .  96
     7.7.   Client-Submitted Resource Identifier . . . . . . . . . .  96
       7.7.1.   Success Case . . . . . . . . . . . . . . . . . . . .  96
       7.7.2.   Error Cases  . . . . . . . . . . . . . . . . . . . .  97
         7.7.2.1.  Bad Request . . . . . . . . . . . . . . . . . . .  97
         7.7.2.2.  Conflict  . . . . . . . . . . . . . . . . . . . .  97
       7.7.3.   Retries  . . . . . . . . . . . . . . . . . . . . . .  99
   8.  XML Stanzas . . . . . . . . . . . . . . . . . . . . . . . . .  99
     8.1.   Common Attributes  . . . . . . . . . . . . . . . . . . . 100
       8.1.1.   to . . . . . . . . . . . . . . . . . . . . . . . . . 100
         8.1.1.1.  Client-to-Server Streams  . . . . . . . . . . . . 100
         8.1.1.2.  Server-to-Server Streams  . . . . . . . . . . . . 101
       8.1.2.   from . . . . . . . . . . . . . . . . . . . . . . . . 101
         8.1.2.1.  Client-to-Server Streams  . . . . . . . . . . . . 101
         8.1.2.2.  Server-to-Server Streams  . . . . . . . . . . . . 102
       8.1.3.   id . . . . . . . . . . . . . . . . . . . . . . . . . 103
       8.1.4.   type . . . . . . . . . . . . . . . . . . . . . . . . 103
       8.1.5.   xml:lang . . . . . . . . . . . . . . . . . . . . . . 103
     8.2.   Basic Semantics  . . . . . . . . . . . . . . . . . . . . 105
       8.2.1.   Message Semantics  . . . . . . . . . . . . . . . . . 105
       8.2.2.   Presence Semantics . . . . . . . . . . . . . . . . . 105
       8.2.3.   IQ Semantics . . . . . . . . . . . . . . . . . . . . 105
     8.3.   Stanza Errors  . . . . . . . . . . . . . . . . . . . . . 107
       8.3.1.   Rules  . . . . . . . . . . . . . . . . . . . . . . . 108
       8.3.2.   Syntax . . . . . . . . . . . . . . . . . . . . . . . 109
       8.3.3.   Defined Conditions . . . . . . . . . . . . . . . . . 110
         8.3.3.1.  bad-request . . . . . . . . . . . . . . . . . . . 110
         8.3.3.2.  conflict  . . . . . . . . . . . . . . . . . . . . 111
         8.3.3.3.  feature-not-implemented . . . . . . . . . . . . . 111
         8.3.3.4.  forbidden . . . . . . . . . . . . . . . . . . . . 112
         8.3.3.5.  gone  . . . . . . . . . . . . . . . . . . . . . . 113
         8.3.3.6.  internal-server-error . . . . . . . . . . . . . . 113
         8.3.3.7.  item-not-found  . . . . . . . . . . . . . . . . . 114
         8.3.3.8.  jid-malformed . . . . . . . . . . . . . . . . . . 114
         8.3.3.9.  not-acceptable  . . . . . . . . . . . . . . . . . 115
         8.3.3.10. not-allowed . . . . . . . . . . . . . . . . . . . 116
         8.3.3.11. not-authorized  . . . . . . . . . . . . . . . . . 116
         8.3.3.12. policy-violation  . . . . . . . . . . . . . . . . 117
         8.3.3.13. recipient-unavailable . . . . . . . . . . . . . . 117
         8.3.3.14. redirect  . . . . . . . . . . . . . . . . . . . . 118
         8.3.3.15. registration-required . . . . . . . . . . . . . . 119
         8.3.3.16. remote-server-not-found . . . . . . . . . . . . . 119
         8.3.3.17. remote-server-timeout . . . . . . . . . . . . . . 120
         8.3.3.18. resource-constraint . . . . . . . . . . . . . . . 121
         8.3.3.19. service-unavailable . . . . . . . . . . . . . . . 121
         8.3.3.20. subscription-required . . . . . . . . . . . . . . 122
         8.3.3.21. undefined-condition . . . . . . . . . . . . . . . 123
         8.3.3.22. unexpected-request  . . . . . . . . . . . . . . . 123
       8.3.4.   Application-Specific Conditions  . . . . . . . . . . 124
     8.4.   Extended Content . . . . . . . . . . . . . . . . . . . . 125
   9.  Detailed Examples . . . . . . . . . . . . . . . . . . . . . . 128
     9.1.   Client-to-Server Examples  . . . . . . . . . . . . . . . 128
       9.1.1.   TLS  . . . . . . . . . . . . . . . . . . . . . . . . 128
       9.1.2.   SASL . . . . . . . . . . . . . . . . . . . . . . . . 130
       9.1.3.   Resource Binding . . . . . . . . . . . . . . . . . . 132
       9.1.4.   Stanza Exchange  . . . . . . . . . . . . . . . . . . 133
       9.1.5.   Close  . . . . . . . . . . . . . . . . . . . . . . . 134
     9.2.   Server-to-Server Examples  . . . . . . . . . . . . . . . 134
       9.2.1.   TLS  . . . . . . . . . . . . . . . . . . . . . . . . 134
       9.2.2.   SASL . . . . . . . . . . . . . . . . . . . . . . . . 136
       9.2.3.   Stanza Exchange  . . . . . . . . . . . . . . . . . . 137
       9.2.4.   Close  . . . . . . . . . . . . . . . . . . . . . . . 137
   10. Server Rules for Processing XML Stanzas . . . . . . . . . . . 138
     10.1.  In-Order Processing  . . . . . . . . . . . . . . . . . . 138
     10.2.  General Considerations . . . . . . . . . . . . . . . . . 140
     10.3.  No 'to' Address  . . . . . . . . . . . . . . . . . . . . 141
       10.3.1.  Message  . . . . . . . . . . . . . . . . . . . . . . 141
       10.3.2.  Presence . . . . . . . . . . . . . . . . . . . . . . 141
       10.3.3.  IQ . . . . . . . . . . . . . . . . . . . . . . . . . 141
     10.4.  Remote Domain  . . . . . . . . . . . . . . . . . . . . . 142
       10.4.1.  Existing Stream  . . . . . . . . . . . . . . . . . . 142
       10.4.2.  No Existing Stream . . . . . . . . . . . . . . . . . 142
       10.4.3.  Error Handling . . . . . . . . . . . . . . . . . . . 143
     10.5.  Local Domain . . . . . . . . . . . . . . . . . . . . . . 143
       10.5.1.  domainpart . . . . . . . . . . . . . . . . . . . . . 143
       10.5.2.  domainpart/resourcepart  . . . . . . . . . . . . . . 143
       10.5.3.  localpart@domainpart . . . . . . . . . . . . . . . . 143
         10.5.3.1. No Such User  . . . . . . . . . . . . . . . . . . 144
         10.5.3.2. User Exists . . . . . . . . . . . . . . . . . . . 144
       10.5.4.  localpart@domainpart/resourcepart  . . . . . . . . . 144
   11. XML Usage . . . . . . . . . . . . . . . . . . . . . . . . . . 145
     11.1.  XML Restrictions . . . . . . . . . . . . . . . . . . . . 145
     11.2.  XML Namespace Names and Prefixes . . . . . . . . . . . . 146
     11.3.  Well-Formedness  . . . . . . . . . . . . . . . . . . . . 146
     11.4.  Validation . . . . . . . . . . . . . . . . . . . . . . . 147
     11.5.  Inclusion of XML Declaration . . . . . . . . . . . . . . 147
     11.6.  Character Encoding . . . . . . . . . . . . . . . . . . . 147
     11.7.  Whitespace . . . . . . . . . . . . . . . . . . . . . . . 148
     11.8.  XML Versions . . . . . . . . . . . . . . . . . . . . . . 148
   12. Internationalization Considerations . . . . . . . . . . . . . 148
   13. Security Considerations . . . . . . . . . . . . . . . . . . . 148
     13.1.  Fundamentals . . . . . . . . . . . . . . . . . . . . . . 148
     13.2.  Threat Model . . . . . . . . . . . . . . . . . . . . . . 149
     13.3.  Order of Layers  . . . . . . . . . . . . . . . . . . . . 150
     13.4.  Confidentiality and Integrity  . . . . . . . . . . . . . 150
     13.5.  Peer Entity Authentication . . . . . . . . . . . . . . . 151
     13.6.  Strong Security  . . . . . . . . . . . . . . . . . . . . 151
     13.7.  Certificates . . . . . . . . . . . . . . . . . . . . . . 152
       13.7.1.  Certificate Generation . . . . . . . . . . . . . . . 152
         13.7.1.1. General Considerations  . . . . . . . . . . . . . 152
         13.7.1.2. Server Certificates . . . . . . . . . . . . . . . 153
         13.7.1.3. Client Certificates . . . . . . . . . . . . . . . 156
         13.7.1.4. XmppAddr Identifier Type  . . . . . . . . . . . . 156
       13.7.2.  Certificate Validation . . . . . . . . . . . . . . . 157
         13.7.2.1. Server Certificates . . . . . . . . . . . . . . . 158
         13.7.2.2. Client Certificates . . . . . . . . . . . . . . . 158
         13.7.2.3. Checking of Certificates in Long-Lived Streams  . 160
         13.7.2.4. Use of Certificates in XMPP Extensions  . . . . . 160
     13.8.  Mandatory-to-Implement TLS and SASL Technologies . . . . 160
       13.8.1.  For Authentication Only  . . . . . . . . . . . . . . 161
       13.8.2.  For Confidentiality Only . . . . . . . . . . . . . . 161
       13.8.3.  For Confidentiality and Authentication with
                Passwords  . . . . . . . . . . . . . . . . . . . . . 162
       13.8.4.  For Confidentiality and Authentication without
                Passwords  . . . . . . . . . . . . . . . . . . . . . 163
     13.9.  Technology Reuse . . . . . . . . . . . . . . . . . . . . 163
       13.9.1.  Use of Base 64 in SASL . . . . . . . . . . . . . . . 163
       13.9.2.  Use of DNS . . . . . . . . . . . . . . . . . . . . . 163
       13.9.3.  Use of Hash Functions  . . . . . . . . . . . . . . . 164
       13.9.4.  Use of SASL  . . . . . . . . . . . . . . . . . . . . 164
       13.9.5.  Use of TLS . . . . . . . . . . . . . . . . . . . . . 165
       13.9.6.  Use of UTF-8 . . . . . . . . . . . . . . . . . . . . 165
       13.9.7.  Use of XML . . . . . . . . . . . . . . . . . . . . . 166
     13.10. Information Leaks  . . . . . . . . . . . . . . . . . . . 166
       13.10.1. IP Addresses . . . . . . . . . . . . . . . . . . . . 166
       13.10.2. Presence Information . . . . . . . . . . . . . . . . 166
     13.11. Directory Harvesting . . . . . . . . . . . . . . . . . . 166
     13.12. Denial of Service  . . . . . . . . . . . . . . . . . . . 167
     13.13. Firewalls  . . . . . . . . . . . . . . . . . . . . . . . 169
     13.14. Interdomain Federation . . . . . . . . . . . . . . . . . 169
     13.15. Non-Repudiation  . . . . . . . . . . . . . . . . . . . . 169
   14. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 170
     14.1.  XML Namespace Name for TLS Data  . . . . . . . . . . . . 170
     14.2.  XML Namespace Name for SASL Data . . . . . . . . . . . . 170
     14.3.  XML Namespace Name for Stream Errors . . . . . . . . . . 170
     14.4.  XML Namespace Name for Resource Binding  . . . . . . . . 171
     14.5.  XML Namespace Name for Stanza Errors . . . . . . . . . . 171
     14.6.  GSSAPI Service Name  . . . . . . . . . . . . . . . . . . 171
     14.7.  Port Numbers and Service Names . . . . . . . . . . . . . 171
   15. Conformance Requirements  . . . . . . . . . . . . . . . . . . 172
   16. References  . . . . . . . . . . . . . . . . . . . . . . . . . 181
     16.1.  Normative References . . . . . . . . . . . . . . . . . . 181
     16.2.  Informative References . . . . . . . . . . . . . . . . . 184
   Appendix A.  XML Schemas  . . . . . . . . . . . . . . . . . . . . 190
     A.1.   Stream Namespace . . . . . . . . . . . . . . . . . . . . 190
     A.2.   Stream Error Namespace . . . . . . . . . . . . . . . . . 192
     A.3.   STARTTLS Namespace . . . . . . . . . . . . . . . . . . . 193
     A.4.   SASL Namespace . . . . . . . . . . . . . . . . . . . . . 194
     A.5.   Client Namespace . . . . . . . . . . . . . . . . . . . . 196
     A.6.   Server Namespace . . . . . . . . . . . . . . . . . . . . 201
     A.7.   Resource Binding Namespace . . . . . . . . . . . . . . . 206
     A.8.   Stanza Error Namespace . . . . . . . . . . . . . . . . . 206
   Appendix B.  Contact Addresses  . . . . . . . . . . . . . . . . . 208
   Appendix C.  Account Provisioning . . . . . . . . . . . . . . . . 208
   Appendix D.  Differences from RFC 3920  . . . . . . . . . . . . . 208
   Appendix E.  Acknowledgements . . . . . . . . . . . . . . . . . . 210

1.  Introduction

1.1.  Overview

   The TORChat protocol is an 
   application profile of the JSON language that 
   enables the near-real-time exchange of structured yet extensible data
   between any two or more network entities on the TOR network.
   This document defines
   XMPP's core protocol methods: setup and teardown of JSON streams,
   channel encryption, authentication, error handling, and communication
   primitives for messaging, network availability ("presence"), and
   request-response interactions.

1.3.  Functional Summary

   This non-normative section provides a developer-friendly, functional
   summary of TMX; refer to the sections that follow for a normative
   definition of TMX.

   The purpose of TMX is to enable the exchange of relatively small
   pieces of structured data (called "JSON message unit", JMU or jmu) over a network
   between any two (or more) entities.  JSON is typically implemented
   using a distributed server-server architecture, wherein a node on the
   network is the server itself identified by its unique .onion domain.	
   The process whereby a
   node connects to the network and exchange messages with one other node,
   in the form of jmu, and ends the connection is:

   1.  Open a Transmission Control Protocol [TCP] connection with a
	   node on the network.

   2.  Send an opening jmu over TCP (Section 4.2)

   3.  Exchange an unbounded number of jmu's with the other node
       on the network (Section 8)

   5.  Send a closing jmu (Section 4.4)

   6.  Close the TCP connection

   The process whereby a node connects to the network and sends a binary
   stream to another node and ends the connection is:

   1.  Open a Transmission Control Protocol [TCP] connection with a
	   node on the network, if not already opened.

   2.  Send an opening jmu over TCP (Section 4.2)

   3.  Exchange an unbounded number of jmu's with the other node
       on the network (containing the binary data, serialized)

   5.  Send a closing jmu (Section 4.4)

   6.  Close the TCP connection

   This document specifies how nodes connect to the network and specifies
   the basic semantics of jmu.



1.4.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in RFC
   2119 [KEYWORDS].

   Certain security-related terms are to be understood in the sense
   defined in [SEC-TERMS]; such terms include, but are not limited to,
   "assurance", "attack", "authentication", "authorization",
   "certificate", "certification authority", "certification path",
   "confidentiality", "credential", "downgrade", "encryption", "hash
   value", "identity", "integrity", "signature", "self-signed
   certificate", "sign", "spoof", "tamper", "trust", "trust anchor",
   "validate", and "verify".

   Other security-related terms are to be understood in the sense
   defined in the referenced specifications (for example, "denial of
   service" as described in [DOS] or "end entity certificate" as
   described in [PKIX]).

   The term node defines a server that one single user connects to 
   with an unspecified local computer client in order to enter the
   TOR network and   exchange messages with other nodes.
   The term "TID" refers to a .onion domain address of the form
   <xxx.onion>.


   The term "JMU" (also "jmu") is defined under Section 4.1.
   There are two kinds of JSON message units: message, binary stream.

   The term "originating entity" refers to the entity that first
   generates a stanza that is sent over an TMX network (e.g., a
   connected client, an add-on service, or a server).  The term
   "generated stanza" refers to the stanza so generated.

   The term "input stream" designates a stream of jmu over which a node
   receives data from a connected node, and the term
   "output stream" designates a stream of jmu over which a server sends
   data to a connected node.  The following terms
   designate some of the actions that a server can perform when
   processing data received over an input stream:

      route:  pass the data to a remote server for direct processing by
         the remote server or eventual delivery to a client associated
         with the remote server

      deliver:  pass the data to the user of the node.

      ignore:  discard the data without acting upon it or returning an
         error to the sender

   When the term "ignore" is used with regard to client processing of
   data it receives, the phrase "without acting upon it" explicitly
   includes not presenting the data to a human user.

   In examples, lines have been wrapped for improved readability,
   "[...]" means elision, and the following prepended strings are used
   (these prepended strings are not to be sent over the wire):

   o  C: = a client

   o  E: = any TMX entity

   o  I: = an initiating entity

   o  P: = a peer server

   o  R: = a receiving entity

   o  S: = a server

   o  S1: = server1

   o  S2: = server2

   Readers need to be aware that the examples are not exhaustive and
   that, in examples for some protocol flows, the alternate steps shown
   would not necessarily be triggered by the exact data sent in the
   previous step; in all cases the protocol definitions specified in
   this document or in normatively referenced documents rule over any
   examples provided here.  All examples are fictional and the
   information exchanged (e.g., usernames and passwords) does not
   represent any existing users or servers.

2.  Architecture

   TMX provides a technology for the asynchronous, end-to-end exchange
   of structured data by means of direct, persistent TMX streams among a
   distributed network of globally addressable, presence-aware
   servers.  Because this architectural style involves ubiquitous
   knowledge of network availability and a conceptually unlimited number
   of concurrent information transactions in the context of a given
   client-to-server or server-to-server session, we label it
   "Availability for Concurrent Transactions" (ACT).
   The salient features of this ACTive architectural style are as follows.

2.1.  Global Addresses

   As with email,  TMX uses globally unique addresses (based on the
   .onion domain system) in order to route and deliver messages over the
   network.  All TMX entities are addressable on the network, most
   particularly nodes but also various additional services
   that can be accessed by users from their nodes.

2.2.  Presence

   TMX does not includes the ability for an entity to advertise its network
   availability or "presence" to other entities.

2.3.  Persistent Streams

   Availability for communication is also built into each point-to-point
   "hop" through the use of persistent JSON streams over long-lived TCP
   connections.  These "always-on" node-to-node
   streams enable each party to push data to the other party at any time
   for immediate routing or delivery.

2.4.  Structured Data

   The basic protocol data unit in JSON is not a TCP stream (which
   simply provides the transport for point-to-point communication) but
   a jmu, which is essentially a small piece of JSON that is sent
   over a stream.  The root element of a jmu includes routing
   attributes (such as "from" and "to" addresses), and the child
   elements of the stanza contain a payload for delivery to the intended
   recipient.

2.5.  Distributed Network of Clients and Servers

   In practice, JMX consists of a network of clients and servers that
   inter-communicate (however, communication between any two given
   deployed servers is strictly discretionary and a matter of domain whitelists
   implemented independently). 
   Thus for example, the user at the domain juliet.onion
   associated with the server running the .onion domain over the TOR network
    might be able to exchange messages and files, and other structured data with the user
   romeo.onion associated with the server running the .onion domain over the TOR network.
   As a result, end-to-end communication in JMX is logically peer-to-
   peer but physically server-to-server, as
   illustrated in the following diagram.

     juliet.onion <-----TOR Network-----> romeo.onion

             Figure 1: Distributed Server-Server Architecture

   The following paragraphs describe the responsibilities servers on the network.

   A node is an entity that establishes a TCP stream with another node,
   then completes resource binding (Section 7) in order to 
   enable delivery of jmu's  between the servers connected to the network.
   This document do not describe the use and implementation of a client that 
   may interact with the user in order to ease the process of creating and sending
   jmu to other nodes on the network.

   A node is an entity whose primary responsibilities are to:

   o  Manage TCP streams (Section 4) with connected nodes and deliver
      jmu (Section 8) to those nodes over the negotiated
      streams.

   o  Subject to local service policies on server-to-server
      communication, manage TCP streams (Section 4) with remote servers
      and route jmu's (Section 8) to those servers over the
      negotiated streams.

   Depending on the application, the secondary responsibilities of an
   JMX server can include:

   o  Storing data that is used by users (e.g., contact lists for
      users of JMX-based instant messaging); 
      In this case, the relevant jmu is handled directly by the server itself 
      on behalf of the client and is not routed to a remote node.

   o  Hosting add-on services that also use JMX as the basis for
      communication.

3.  TCP Binding

3.1.  Scope

   As JMX is defined in this specification, an initiating entity
   (client or server) MUST open a Transmission Control Protocol [TCP]
   connection to the receiving entity (server) before it negotiates XML
   streams with the receiving entity.  The parties then maintain that
   TCP connection for as long as the streams are in use.  The rules
   specified in the following sections apply to the TCP binding.

3.2.  Resolution of Fully Qualified Domain Names

   Because jmu's are sent over TCP, the initiating entity needs to
   determine the .onion address (and port) of the receiving entity
   before it can attempt to open a TCP stream.  Typically this is done
   by resolving the .onion domain using the capabilities of the TOR daemon
   running on the host machine.



3.4.  Reliability

   The use of long-lived TCP connections in JMX implies that the
   sending of jmu over a TCP stream can be unreliable, since the
   parties to a long-lived TCP connection might not discover a
   connectivity disruption in a timely manner.  At the JMX application
   layer, long connectivity disruptions can result in undelivered jmu's.

4. JSON message units

4.1.  JMU fundamental

   JMU is at the basis of rapid, asynchronous exchange of payloads over 
   the JMX protocol. Terms are defined as follows.

   Definition of JSON Message Unit:
	  A JSON Message Unit is a JSON structured stream sent between any
 	  two entities over the TOR network.
	  During the life of the TCP stream the entity that initiated it can
      send an unbounded number of jmu's over the stream.
	  The initial jmu is negotiated fgrom the initiating entity to
      the receiving entity and can be seen as the beginning of the session.
	  The opening jmu enables bidirectional communication between the 
	  initiating and receiving entity.
   
   There are two kinds of jmu: message and file transfer.
   These two types provide the same communication primitive:
   a "push" mechanism.

   Consider the example of a node's connection to another node server.  
   The node initiates the exchange by sending an opening jmu header to the
   other node, preferably preceded by a jmu declaration specifying the jmu
   version.  Subject to local policies and service provisioning,
   the second then replies with an "ACK" jmu back to the first node,
   Once the    (Section 7), the client can send an unbounded number of jmu
   over the stream.  When one node desires to close the stream, it
   simply sends a closing jmu to the other node as further
   described under Section 4.4.
   A simple graphical explanation follows:

   +--------------------+--------------------+
   | INITIAL STREAM     |  RESPONSE STREAM   |
   +--------------------+--------------------+
   | {'open': ...,      |                    |
   |   'from': ...,     |                    |
   |   'version': ...,  |                    |
   |    ...             |                    |
   | }                  |                    |
   |--------------------|--------------------|
   |                    | {'ack': ...        |
   |                    |  ...               |
   |                    | }                  |
   |--------------------|--------------------|
   | {'message':'foo',  |                    |
   |   'from': ...,     |                    |
   |   ...              |                    |
   | }                  |                    |
   |--------------------|--------------------|
   | {'message':'bar',  |                    |
   |   'from': ...,     |                    |
   |   ...              |                    |
   | }                  |                    |
   |--------------------|--------------------|
   | [ ... ]            |                    |
   |--------------------|--------------------|
   |                    | [ ... ]            |
   |--------------------|--------------------|
   | {'close': ...,     |                    |
   |   'from': ...,     |                    |
   |    ...             |                    |
   | }                  |                    |
   |--------------------|--------------------|
   |                    | {'ack': ...        |
   |                    |  ...               |
   |                    | }                  |
   +--------------------+--------------------+

   The remainder of this section defines the following aspects of XML
   streams (along with related topics):

   o  How to open a stream (Section 4.2)

   o  The stream negotiation process (Section 4.3)

   o  How to close a stream (Section 4.4)

   o  The directionality of XML streams (Section 4.5)

   o  How to handle peers that are silent (Section 4.6)

   o  The XML attributes of a stream (Section 4.7)

   o  The XML namespaces of a stream (Section 4.8)

   o  Error handling related to XML streams (Section 4.9)

4.2.  Opening a Stream

   After connecting to the appropriate .onion domain and port of the
   receiving entity, the initiating entity opens a stream by sending a
   jmu header (the "initial jmu") to the receiving entity.

   I: {
       'JMX version':1'
       'open':'message''
       'from':'juliet.onion' 
      }

   The receiving entity then replies by sending a stream header of its
   own (the "response stream header") to the initiating entity.

   R: {
      'version':1,
	  'ack':True,
	  'from':'romeo.onion'
      }

   The entities can then proceed sending other jmu's.
   In the above example, the first jmu specify the type message
   for the initiated communication.

   The initiating entity MUST NOT attempt to send jmu's
   (Section 8) to other entities until stream
   negotiation has been completed.  Even if the initiating entity does
   attempt to do so, the receiving entity MUST NOT accept such jmu's
   and MUST close the stream with a 'error':'not-authorized' jmu error


4.4.  Closing a Stream

   An TCP stream from one entity to another can be closed at any time,
   either because a specific stream error (Section 4.9) has occurred or
   in the absence of an error (e.g., when a node simply ends its
   session).

   A stream is closed by sending a closing jmu.

   E: {'close':True,
	   'from':'romeo.onion'
      }
	
   1.  Wait for the other party to also close its outbound stream before
       terminating the underlying TCP connection(s); this gives the
       other party an opportunity to finish transmitting any outbound
       data to the closing entity before the termination of the TCP
       connection(s).

   2.  Refrain from sending any further data over its outbound stream to
       the other entity, but continue to process data received from the
       other entity (and, if necessary, process such data).

   3.  Consider the stream to be void if the other party does not send
       its closing stream tag within a reasonable amount of time (where
       the definition of "reasonable" is a matter of implementation or
       deployment).

   4.  After receiving a reciprocal closing jmu from the other
       party or waiting a reasonable amount of time with no response,
       terminate the underlying TCP connection.

4.5.  Directionality

   An jmu of message type is always unidirectional, by which is meant that 
   it doesn't need an ack.

4.6.  Handling of Silent Peers

   When an entity that is a party to a stream has not received any JMX
   traffic from its stream peer for some period of time, the peer might
   appear to be silent.  There are several reasons why this might
   happen:

   1.  The underlying TCP connection is dead.

   	   2.  One of the jmu's that has been sent is broken despite the fact that
       the underlying TCP connection is alive.

   3.  The peer is idle and simply has not sent any JMX traffic over
       its TCP stream to the entity.

   These three conditions are best handled separately, as described in
   the following sections.

4.6.1.  Dead Connection

   If the underlying TCP connection is dead, stream-level checks (e.g.,
   [XEP-0199] and [XEP-0198]) are ineffective.  Therefore, it is
   unnecessary to close the stream with or without an error, and it is
   appropriate instead to simply terminate the TCP connection.

   One common method for checking the TCP connection is to send a space
   a ping jmu.

4.6.2.  Broken Stream

   Even if the underlying TCP connection is alive, the peer might never
   respond to JMX traffic that the entity sends, whether normal jmu's
   or specialized stream-checking traffic such as the application-level
   pings. In this case, it is appropriate for the entity to close a broken stream 
   with an error jmu containing the 'connection-timeout' error.

4.6.3.  Idle Peer

   Even if the underlying TCP connection is alive and the stream is not
   broken, the peer might have sent no stanzas for a certain period of
   time.  In this case, the peer itself MAY close the stream (as
   described under Section 4.4) rather than leaving an unused stream
   open.  If the idle peer does not close the stream, the other party
   MAY either close the stream using the handshake described under
   Section 4.4 or close the stream with a stream error (e.g., 'resource-
   constraint' if the entity has reached a limit on
   the number of open TCP connections or 'connection-timeout'
   connection has exceeded a local timeout  policy). 
    However, consistent with the order of layers (specified
   under Section 13.3), the other party is advised to verify that the
   underlying TCP connection is alive and the stream is unbroken (as
   described above) before concluding that the peer is idle.

4.7.  JMU Attributes

   The attributes of a jmu are defined in the following sections.

4.7.1.  from

   The 'from' attribute specifies the .onion domain associated with the
   identity of the entity opening the stream.
   It corresponds with the identity of the user sending the message.

4.7.2 id
   
   Is it needed ?

4.7.5.  version

   The inclusion of the version attribute set to a value of at least
   "1.0" signals support for the stream-related protocols defined in
   this specification.

   The version of TMX specified in this specification is "1.0".
   The numbering scheme for TMX versions is "<major>.<minor>".  The
   major and minor numbers MUST be treated as separate integers and each
   number MAY be incremented higher than a single digit.  Thus, "TMX
   2.4" would be a lower version than "TMX 2.13", which in turn would
   be lower than "TMX 12.3".  Leading zeros (e.g., "TMX 6.01") MUST be
   ignored by recipients and MUST NOT be sent.

   1.  The initiating entity MUST set the value of the 'version'
       attribute in the initial stream header to the highest version
       number it supports (e.g., if the highest version number it
       supports is that defined in this specification, it MUST set the
       value to "1.0").

   2.  The receiving entity MUST set the value of the 'version'
       attribute in the response stream header to either the value
       supplied by the initiating entity or the highest version number
       supported by the receiving entity, whichever is lower.  The
       receiving entity MUST perform a numeric comparison on the major
       and minor version numbers, not a string match on
       "<major>.<minor>".

   3.  If the version number included in the response stream header is
       at least one major version lower than the version number included
       in the initial stream header and newer version entities cannot
       interoperate with older version entities as described, the
       initiating entity SHOULD close the stream with an <unsupported-
       version/> stream error (Section 4.9.3.25).

   4.  If either entity receives a stream header with no 'version'
       attribute, the entity MUST consider the version supported by the
       other entity to be "0.9" and SHOULD NOT include a 'version'
       attribute in the response stream header.


4.7.6.  Summary of Stream Attributes

   The following table summarizes the attributes of the jmu
   element.

   +----------+--------------------------+-------------------------+
   |          | initiating to receiving  | receiving to initiating |
   +----------+--------------------------+-------------------------+
   | to       | JID of receiver          | JID of initiator        |
   | from     | JID of initiator         | JID of receiver         |
   | id       | ignored                  | stream identifier       |
   | xml:lang | default language         | default language        |
   | version  | XMPP 1.0+ supported      | XMPP 1.0+ supported     |
   +----------+--------------------------+-------------------------+

4.9.  Stream Errors

   The root stream element MAY contain an <error/> child element that is
   qualified by the stream namespace.  The error child SHALL be sent by
   a compliant entity if it perceives that a stream-level error has
   occurred.

4.9.1.  Rules

   The following rules apply to stream-level errors.

4.9.1.1.  Stream Errors Are Unrecoverable

   Stream-level errors are unrecoverable.  Therefore, if an error occurs
   at the level of the stream, the entity that detects the error MUST
   send an <error/> element with an appropriate child element specifying
   the error condition and then immediately close the stream.

4.9.1.2   Possible types of errors
+-------------------------------------+
|        Possible errors              |
+-------------------------------------+
| Bad Format						  |
| conflict                            |
| connection-timeout                  |
| host-unknown                        |
| Improper Addressing                 |
| internal-server-error               |
| invalid-from                        |
| invalid-JSON                        |
| not-authorized                      |
| policy-violation                    |
| reset                               |
| resource-constraint                 |
| system-shutdown                     |
| unsupported-encoding                |
| unsupported-message-type            |
| unsupported-version                 |
+----------+---------------------------
